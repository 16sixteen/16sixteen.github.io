---
layout:     post
title:      "设计模式-设计模式入门（3）"
subtitle:   "设计原则 装饰者模式"
date:       2016-07-14 11:15:00
categories: DesignPattern
tags:       设计模式
author:     "SixTeen"
header-img: "img/designPattern.jpg"
published:   true
---

* TOC
{:toc}

### 装饰者模式

要理解设计模式，最简单的方法就是看类图。下面是我使用umlet把书上的类图画下来：

![class uml](/img/unity3d/daylearning/7.14/class.png)

从类图中可以很容易的看出，装饰者模式以组合的形式，使得系统变得可扩展又不需要修改原有代码。（组件使用接口或者超类来实现都是可以的，装饰者模式的核心是组合的思想）

#### 举例：咖啡店系统

举个例子，一个咖啡店系统，加糖加奶需要额外收费，如果编写一个咖啡类，再继承编写加糖咖啡类，加奶咖啡类，加奶加糖咖啡类，一但多一个调料，那么类将会以指数爆炸的级别增长。另一方面，如果某一类调料价格发生变化，那么需要修改的类将是毁灭性的多，而且每新加一种咖啡就需要再多写无数的子类。而对于装饰者模式实现的咖啡店系统，我们增加一种调料只需要继承装饰者的父类再实现一个子类即可，调料价格发生改变，只需要改变对应调料的类的价格即可，多加一种新咖啡，只需要多实现一个具体的咖啡组件类即可。

可以看出，装饰者模式能让系统容易扩展修改，又不需要大部分修改核心代码。

### 一些概念

#### 组合和继承

> 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时及动态地进行扩展

> 通过动态地组合对象，可以写新的代码添加新功能，而无需修改现有代码，既然没有改变现有代码，那么引进bug或产生意外副作用的机会将大幅度减少

#### 设计原则

> 类应该对扩展开放，对修改关闭。

#### 装饰者模式

> 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

> 装饰者和被装饰者对象具有相同类型的超类，所以在任何需要原始对象（被装饰对象）的场合，都可以用装饰过的对象替代它。

> 装饰者可以在所委托被装饰者的行为之前与之后，加上自己的行为，以达到特定的目的。


<br/><br/><br/>

>参考书籍：<br/>《Head First设计模式》

    FIN 2016.7.25/14.49



